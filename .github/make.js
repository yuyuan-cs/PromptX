#!/usr/bin/env node

/**
 * GitHub Workflows è§£å†³æ–¹æ¡ˆç»„è£…è„šæœ¬
 * ç”¨æ³•: node make.js <solution-name> [target-dir]
 */

const fs = require('fs');
const path = require('path');
const yaml = require('js-yaml');
const { execSync } = require('child_process');

// é¢œè‰²è¾“å‡º
const colors = {
  red: '\x1b[31m',
  green: '\x1b[32m',
  yellow: '\x1b[33m',
  reset: '\x1b[0m'
};

function log(message, color = 'reset') {
  console.log(`${colors[color]}${message}${colors.reset}`);
}

function error(message) {
  log(`âŒ ${message}`, 'red');
  process.exit(1);
}

function success(message) {
  log(`âœ… ${message}`, 'green');
}

function info(message) {
  log(`ğŸ“‹ ${message}`, 'yellow');
}

// è§£æå‘½ä»¤è¡Œå‚æ•°
const args = process.argv.slice(2);
if (args.length < 1) {
  error('è¯·æŒ‡å®šè§£å†³æ–¹æ¡ˆåç§°\nç”¨æ³•: node make.js <solution-name> [target-dir]');
}

const solutionName = args[0];
const targetDir = args[1] || '.';
const solutionFile = path.join(__dirname, 'solutions', solutionName, 'solution.yml');

// æ£€æŸ¥è§£å†³æ–¹æ¡ˆæ˜¯å¦å­˜åœ¨
if (!fs.existsSync(solutionFile)) {
  error(`è§£å†³æ–¹æ¡ˆ '${solutionName}' ä¸å­˜åœ¨`);
}

// è¯»å–è§£å†³æ–¹æ¡ˆé…ç½®
const solutionConfig = yaml.load(fs.readFileSync(solutionFile, 'utf8'));

log(`\nğŸš€ å¼€å§‹ç»„è£…è§£å†³æ–¹æ¡ˆ: ${solutionName}`, 'green');
info(solutionConfig.description);

// é…ç½®
const outputPath = path.join(targetDir, solutionConfig.output?.path || '.github');
const mergeWorkflows = solutionConfig.output?.merge_workflows ?? true;

// åˆ›å»ºç›®æ ‡ç›®å½•
function ensureDir(dir) {
  if (!fs.existsSync(dir)) {
    fs.mkdirSync(dir, { recursive: true });
  }
}

ensureDir(path.join(outputPath, 'workflows'));
ensureDir(path.join(outputPath, 'ISSUE_TEMPLATE'));

// 1. å¤åˆ¶åˆ†æ”¯ç­–ç•¥
function copyBranchStrategy() {
  log('\n1. é…ç½®åˆ†æ”¯ç­–ç•¥', 'green');
  const strategy = solutionConfig.components.branch_strategy;
  const strategyFile = path.join(__dirname, 'branches', 'strategies', `${strategy}.yml`);
  
  if (fs.existsSync(strategyFile)) {
    fs.copyFileSync(strategyFile, path.join(outputPath, 'branch-strategy.yml'));
    success(`å·²å¤åˆ¶åˆ†æ”¯ç­–ç•¥: ${strategy}`);
  } else {
    error(`åˆ†æ”¯ç­–ç•¥ '${strategy}' ä¸å­˜åœ¨`);
  }
}

// 2. ç»„è£…å‘½ä»¤å·¥ä½œæµ
function assembleCommands() {
  log('\n2. ç»„è£…å‘½ä»¤å·¥ä½œæµ', 'green');
  const commands = solutionConfig.components.commands || [];
  
  if (mergeWorkflows) {
    // TODO: åˆå¹¶æ‰€æœ‰å‘½ä»¤åˆ°ä¸€ä¸ªå·¥ä½œæµï¼ˆéœ€è¦å¤æ‚çš„ YAML åˆå¹¶é€»è¾‘ï¼‰
    log('   åˆå¹¶æ¨¡å¼æš‚æœªå®ç°ï¼Œä½¿ç”¨ç‹¬ç«‹å·¥ä½œæµæ¨¡å¼', 'yellow');
  }
  
  // å¤åˆ¶æ¯ä¸ªå‘½ä»¤çš„å·¥ä½œæµ
  commands.forEach(cmd => {
    const cmdFile = path.join(__dirname, 'commands', cmd, `${cmd}.yml`);
    if (fs.existsSync(cmdFile)) {
      fs.copyFileSync(cmdFile, path.join(outputPath, 'workflows', `${cmd}.yml`));
      success(`å¤åˆ¶å‘½ä»¤: /${cmd}`);
    } else {
      log(`   âš ï¸  å‘½ä»¤ '${cmd}' ä¸å­˜åœ¨`, 'yellow');
    }
  });
}

// 2.5 ç»„è£…äº‹ä»¶è§¦å‘å™¨ï¼ˆæ–°æ¶æ„ï¼šé€æ˜çš„è‡ªåŠ¨åŒ–ï¼‰
function assembleEvents() {
  const events = solutionConfig.components.events || [];
  const flows = solutionConfig.components.flows || []; // ä¿æŒå‘åå…¼å®¹
  
  // åˆå¹¶ events å’Œ flowsï¼ˆå‘åå…¼å®¹ï¼‰
  const allAutomations = [...new Set([...events, ...flows])];
  
  if (allAutomations.length === 0) return;
  
  log('\n2.5 ç»„è£…è‡ªåŠ¨åŒ–è§¦å‘å™¨', 'green');
  
  allAutomations.forEach(item => {
    // ä¼˜å…ˆæŸ¥æ‰¾ events ç›®å½•
    let sourceFile = path.join(__dirname, 'events', item, `${item}.yml`);
    let sourceType = 'event';
    
    // å¦‚æœ events ä¸­ä¸å­˜åœ¨ï¼Œå°è¯• flows ç›®å½•ï¼ˆå‘åå…¼å®¹ï¼‰
    if (!fs.existsSync(sourceFile)) {
      sourceFile = path.join(__dirname, 'flows', item, `${item}.yml`);
      sourceType = 'flow';
    }
    
    if (fs.existsSync(sourceFile)) {
      fs.copyFileSync(sourceFile, path.join(outputPath, 'workflows', `${item}.yml`));
      success(`å¤åˆ¶${sourceType === 'event' ? 'äº‹ä»¶' : 'æµç¨‹'}: ${item}`);
    } else {
      log(`   âš ï¸  ${item} ä¸å­˜åœ¨äº events æˆ– flows ç›®å½•`, 'yellow');
    }
  });
}

// 3. ç”Ÿæˆæ ‡ç­¾é…ç½®
function generateLabels() {
  log('\n3. ç”Ÿæˆæ ‡ç­¾é…ç½®', 'green');
  const labels = solutionConfig.components.labels || {};
  const labelsFile = path.join(outputPath, 'labels.yml');
  
  const labelColors = {
    feature: '0e8a16',
    bug: 'd73a4a',
    enhancement: 'a2eeef',
    docs: '0075ca',
    refactor: 'ffd93d',
    critical: 'b60205',
    high: 'd93f0b',
    medium: 'fbca04',
    low: '0e8a16'
  };
  
  let labelsYaml = '# GitHub Issue Labels\n';
  labelsYaml += '# Auto-generated by make.js\n\n';
  
  // ç±»å‹æ ‡ç­¾
  if (labels.types) {
    labelsYaml += '# Type Labels\n';
    labels.types.forEach(label => {
      const colorKey = label.split(':')[1]?.trim() || 'default';
      labelsYaml += `- name: "${label}"\n`;
      labelsYaml += `  color: "${labelColors[colorKey] || 'd876e3'}"\n`;
      labelsYaml += `  description: "${colorKey}"\n\n`;
    });
  }
  
  // ä¼˜å…ˆçº§æ ‡ç­¾
  if (labels.priorities) {
    labelsYaml += '# Priority Labels\n';
    labels.priorities.forEach(label => {
      const colorKey = label.split(':')[1]?.trim() || 'default';
      labelsYaml += `- name: "${label}"\n`;
      labelsYaml += `  color: "${labelColors[colorKey] || 'c5def5'}"\n`;
      labelsYaml += `  description: "${colorKey}"\n\n`;
    });
  }
  
  fs.writeFileSync(labelsFile, labelsYaml);
  success('å·²ç”Ÿæˆæ ‡ç­¾é…ç½®');
}

// 4. å¤åˆ¶ Issue æ¨¡æ¿
function copyIssueTemplates() {
  log('\n4. å¤åˆ¶ Issue æ¨¡æ¿', 'green');
  const templatesDir = path.join(__dirname, 'issues', 'templates');
  
  if (fs.existsSync(templatesDir)) {
    const templates = fs.readdirSync(templatesDir);
    templates.forEach(file => {
      if (file.endsWith('.yml') || file.endsWith('.md')) {
        fs.copyFileSync(
          path.join(templatesDir, file),
          path.join(outputPath, 'ISSUE_TEMPLATE', file)
        );
      }
    });
    success('å·²å¤åˆ¶ Issue æ¨¡æ¿');
  }
}

// 5. ç”Ÿæˆé…ç½®æ–‡æ¡£
function generateConfigDoc() {
  log('\n5. ç”Ÿæˆé…ç½®æ–‡æ¡£', 'green');
  const configDoc = path.join(outputPath, 'WORKFLOW_CONFIG.md');
  
  let doc = `# GitHub Workflow é…ç½®

æ­¤é…ç½®ç”± make.js è‡ªåŠ¨ç”Ÿæˆï¼ŒåŸºäºè§£å†³æ–¹æ¡ˆ: **${solutionConfig.name}**

## é…ç½®ä¿¡æ¯

- **è§£å†³æ–¹æ¡ˆ**: ${solutionConfig.name}
- **æè¿°**: ${solutionConfig.description}
- **åˆ†æ”¯ç­–ç•¥**: ${solutionConfig.components.branch_strategy}
- **ç”Ÿæˆæ—¶é—´**: ${new Date().toISOString()}

## å¯ç”¨çš„å‘½ä»¤

`;

  (solutionConfig.components.commands || []).forEach(cmd => {
    doc += `- \`/${cmd}\`\n`;
  });
  
  doc += '\n## è‡ªåŠ¨åŒ–äº‹ä»¶\n\n';
  
  const events = solutionConfig.components.events || [];
  const flows = solutionConfig.components.flows || [];
  const allAutomations = [...new Set([...events, ...flows])];
  
  if (allAutomations.length > 0) {
    allAutomations.forEach(item => {
      doc += `- \`${item}\`\n`;
    });
  }
  
  doc += '\n## ç¯å¢ƒå˜é‡\n\n';
  
  if (solutionConfig.environment?.secrets) {
    doc += 'éœ€è¦åœ¨ GitHub Settings > Secrets ä¸­é…ç½®ï¼š\n\n';
    solutionConfig.environment.secrets.forEach(secret => {
      doc += `- **${secret.name}**: ${secret.description}\n`;
    });
  }
  
  fs.writeFileSync(configDoc, doc);
  success('å·²ç”Ÿæˆé…ç½®æ–‡æ¡£');
}

// æ‰§è¡Œç»„è£…
try {
  copyBranchStrategy();
  assembleCommands();
  assembleEvents();  // æ›´æ–°å‡½æ•°å
  generateLabels();
  copyIssueTemplates();
  generateConfigDoc();
  
  log('\nâœ… è§£å†³æ–¹æ¡ˆç»„è£…å®Œæˆï¼', 'green');
  
  console.log(`
ä¸‹ä¸€æ­¥æ“ä½œ:
1. è¿›å…¥é¡¹ç›®ç›®å½•: cd ${targetDir}
2. æŸ¥çœ‹ç”Ÿæˆçš„æ–‡ä»¶: ls -la ${outputPath}/
3. æäº¤åˆ° Git: git add ${outputPath} && git commit -m "Add GitHub workflows"
4. æ¨é€åˆ° GitHub: git push

é…ç½® GitHub ä»“åº“:
1. è®¾ç½® Secrets: Settings > Secrets and variables > Actions
2. å¯ç”¨ Actions: Settings > Actions > General
3. é…ç½®åˆ†æ”¯ä¿æŠ¤: Settings > Branches
`);

  if (solutionConfig.environment?.secrets) {
    log('\nâš ï¸  è®°å¾—é…ç½®ä»¥ä¸‹ Secrets:', 'yellow');
    solutionConfig.environment.secrets.forEach(secret => {
      console.log(`   - ${secret.name}`);
    });
  }
} catch (err) {
  error(`ç»„è£…å¤±è´¥: ${err.message}`);
}