name: Release Command

on:
  issue_comment:
    types: [created]

jobs:
  handle-release:
    if: |
      (github.event.issue.pull_request || !github.event.issue.pull_request) &&
      startsWith(github.event.comment.body, '/release')
    runs-on: ubuntu-latest
    
    permissions:
      contents: write
      pull-requests: write
      issues: write
      packages: write
    
    steps:
      - name: Add reaction
        uses: actions/github-script@v7
        with:
          script: |
            await github.rest.reactions.createForIssueComment({
              owner: context.repo.owner,
              repo: context.repo.repo,
              comment_id: context.payload.comment.id,
              content: 'eyes'
            });
      
      - name: Check permissions
        id: permissions
        uses: actions/github-script@v7
        with:
          script: |
            const username = '${{ github.event.comment.user.login }}';
            
            // Allow github-actions bot for automated workflows
            if (username === 'github-actions[bot]' || username === 'github-actions') {
              console.log('Allowing github-actions bot');
              core.setOutput('allowed', true);
              return;
            }
            
            try {
              const { data: perm } = await github.rest.repos.getCollaboratorPermissionLevel({
                owner: context.repo.owner,
                repo: context.repo.repo,
                username: username
              });
              
              const hasPermission = ['admin', 'maintain', 'write'].includes(perm.permission);
              core.setOutput('allowed', hasPermission);
              
              if (!hasPermission) {
                await github.rest.issues.createComment({
                  owner: context.repo.owner,
                  repo: context.repo.repo,
                  issue_number: context.issue.number,
                  body: `âŒ **Permission denied**\n\n@${username} does not have permission to create releases. Only maintainers can use the \`/release\` command.`
                });
                
                await github.rest.reactions.createForIssueComment({
                  owner: context.repo.owner,
                  repo: context.repo.repo,
                  comment_id: context.payload.comment.id,
                  content: '-1'
                });
              }
            } catch (error) {
              core.setOutput('allowed', false);
              console.error('Permission check failed:', error);
            }
      
      - name: Determine branch
        if: steps.permissions.outputs.allowed == 'true'
        id: branch
        uses: actions/github-script@v7
        with:
          script: |
            let branch;
            let sourceBranch;
            
            // Check if this is a PR comment
            if (context.payload.issue.pull_request) {
              const pr = await github.rest.pulls.get({
                owner: context.repo.owner,
                repo: context.repo.repo,
                pull_number: context.issue.number
              });
              
              branch = pr.data.base.ref;  // Target branch (e.g., main)
              sourceBranch = pr.data.head.ref;  // Source branch (e.g., release/1.2.0)
              
              // å…³é”®ä¿®å¤ï¼šæ£€æŸ¥PRæ˜¯å¦å·²åˆå¹¶ï¼Œå†³å®šcheckoutç­–ç•¥
              if (pr.data.merged) {
                // PRå·²åˆå¹¶
                if (branch === 'main' && sourceBranch.startsWith('release/')) {
                  // Release PRåˆå¹¶åˆ°mainåŽï¼Œåº”è¯¥ä»Žmainå‘å¸ƒæ­£å¼ç‰ˆ
                  console.log(`âœ… Release PR merged to main, will checkout from main for production release`);
                  core.setOutput('source_branch', 'main');
                } else {
                  // å…¶ä»–æƒ…å†µä½¿ç”¨ç›®æ ‡åˆ†æ”¯
                  console.log(`PR merged, using target branch: ${branch}`);
                  core.setOutput('source_branch', branch);
                }
                core.setOutput('pr_merged', 'true');
              } else {
                // PRæœªåˆå¹¶ï¼Œä½¿ç”¨æºåˆ†æ”¯ï¼ˆbeta/rcå‘å¸ƒï¼‰
                console.log(`PR not merged, using source branch: ${sourceBranch}`);
                core.setOutput('source_branch', sourceBranch);
                core.setOutput('pr_merged', 'false');
              }
              
              core.setOutput('is_pr', 'true');
              core.setOutput('pr_number', context.issue.number);
            } else {
              // Issue comment - use default branch
              branch = context.payload.repository.default_branch;
              sourceBranch = branch;
              core.setOutput('is_pr', 'false');
              core.setOutput('source_branch', branch);
            }
            
            core.setOutput('branch', branch);
            console.log(`Target branch: ${branch}`);
            console.log(`Source branch: ${sourceBranch}`);
      
      - name: Check branch restrictions
        if: steps.permissions.outputs.allowed == 'true'
        id: branch_check
        uses: actions/github-script@v7
        with:
          script: |
            const targetBranch = '${{ steps.branch.outputs.branch }}';
            const sourceBranch = '${{ steps.branch.outputs.source_branch }}';
            const isPR = '${{ steps.branch.outputs.is_pr }}' === 'true';
            
            // Check if trying to release from develop or dev
            if (!isPR && (targetBranch === 'develop' || targetBranch === 'dev')) {
              core.setOutput('allowed', false);
              await github.rest.issues.createComment({
                owner: context.repo.owner,
                repo: context.repo.repo,
                issue_number: context.issue.number,
                body: `âŒ **Cannot release from ${targetBranch} branch**
                
                Releases should not be done directly from develop/dev branches.
                
                ### Correct workflow:
                1. Run \`/start release\` to create a release branch from develop
                2. The release branch will consume changesets and create a PR to main
                3. Run \`/release beta\` in the release branch PR
                4. After testing, merge to main and run \`/release\` for final version
                
                ### For development versions:
                If you want to publish a development version from ${targetBranch}:
                - Use \`/publish npm --tag dev\` instead`
              });
              
              await github.rest.reactions.createForIssueComment({
                owner: context.repo.owner,
                repo: context.repo.repo,
                comment_id: context.payload.comment.id,
                content: 'confused'
              });
              return;
            }
            
            // For PRs, check if source is a release branch and target is main
            if (isPR) {
              const isReleaseToMain = sourceBranch.startsWith('release/') && targetBranch === 'main';
              const isHotfixToMain = sourceBranch.startsWith('hotfix/') && targetBranch === 'main';
              
              if (!isReleaseToMain && !isHotfixToMain) {
                // Warn but allow - might be a special case
                console.log(`âš ï¸ Warning: Unusual release pattern - ${sourceBranch} â†’ ${targetBranch}`);
              }
            }
            
            // Check if on main branch without PR context (for final releases)
            if (!isPR && targetBranch === 'main') {
              console.log('âœ… Releasing from main branch (final release)');
            }
            
            // Check if on release branch
            if (!isPR && sourceBranch.startsWith('release/')) {
              console.log('âœ… Releasing from release branch (beta/rc)');
            }
            
            core.setOutput('allowed', true);
      
      - name: Checkout branch
        if: steps.permissions.outputs.allowed == 'true' && steps.branch_check.outputs.allowed == 'true'
        uses: actions/checkout@v4
        with:
          token: ${{ secrets.GITHUB_TOKEN }}
          ref: ${{ steps.branch.outputs.source_branch }}
          fetch-depth: 0
      
      - name: Parse command
        if: steps.permissions.outputs.allowed == 'true' && steps.branch_check.outputs.allowed == 'true'
        id: parse
        shell: bash
        run: |
          COMMAND="${{ github.event.comment.body }}"
          echo "Raw command: $COMMAND"
          
          # Default values
          echo "valid=true" >> $GITHUB_OUTPUT
          echo "preview=false" >> $GITHUB_OUTPUT
          echo "graduate=false" >> $GITHUB_OUTPUT
          echo "prerelease=" >> $GITHUB_OUTPUT
          echo "force_version=" >> $GITHUB_OUTPUT
          
          # Parse flags
          if [[ "$COMMAND" =~ --preview ]]; then
            echo "preview=true" >> $GITHUB_OUTPUT
          fi
          
          if [[ "$COMMAND" =~ --graduate ]]; then
            echo "graduate=true" >> $GITHUB_OUTPUT
          fi
          
          if [[ "$COMMAND" =~ --prerelease[[:space:]]+([a-z]+) ]]; then
            echo "prerelease=${BASH_REMATCH[1]}" >> $GITHUB_OUTPUT
          fi
          
          if [[ "$COMMAND" =~ --force-version[[:space:]]+([0-9]+\.[0-9]+\.[0-9]+[^ ]*) ]]; then
            echo "force_version=${BASH_REMATCH[1]}" >> $GITHUB_OUTPUT
          fi
      
      - name: Check version lock
        if: steps.permissions.outputs.allowed == 'true'
        id: lock
        shell: bash
        run: |
          LOCK_FILE=".changeset/prerelease.lock"
          
          if [ -f "$LOCK_FILE" ]; then
            echo "has_lock=true" >> $GITHUB_OUTPUT
            LOCKED_VERSION=$(jq -r '.version' "$LOCK_FILE")
            LOCKED_PRERELEASE=$(jq -r '.prerelease' "$LOCK_FILE")
            LOCKED_COUNTER=$(jq -r '.counter' "$LOCK_FILE")
            
            echo "locked_version=$LOCKED_VERSION" >> $GITHUB_OUTPUT
            echo "locked_prerelease=$LOCKED_PRERELEASE" >> $GITHUB_OUTPUT
            echo "locked_counter=$LOCKED_COUNTER" >> $GITHUB_OUTPUT
            echo "Found version lock: $LOCKED_VERSION-$LOCKED_PRERELEASE.$LOCKED_COUNTER"
          else
            echo "has_lock=false" >> $GITHUB_OUTPUT
            echo "No version lock found"
          fi
      
      - name: Set project type
        if: steps.permissions.outputs.allowed == 'true'
        id: detect
        shell: bash
        run: |
          # PromptX is a Node.js project
          echo "project_type=node" >> $GITHUB_OUTPUT
          echo "Detected project type: node"
      
      - name: Check changesets
        if: |
          steps.permissions.outputs.allowed == 'true' &&
          steps.parse.outputs.graduate != 'true'
        id: changesets
        shell: bash
        run: |
          PROJECT_TYPE="${{ steps.detect.outputs.project_type }}"
          SOURCE_BRANCH="${{ steps.branch.outputs.source_branch }}"
          HAS_CHANGESETS=false
          CHANGESET_COUNT=0
          
          # If on a release branch, skip changeset check (already consumed by /start release)
          if [[ "$SOURCE_BRANCH" =~ ^release/ ]]; then
            echo "ðŸ“¦ On release branch - changesets already consumed during /start release"
            echo "has_changesets=false" >> $GITHUB_OUTPUT
            echo "skip_check=true" >> $GITHUB_OUTPUT
            echo "count=0" >> $GITHUB_OUTPUT
            exit 0
          fi
          
          case "$PROJECT_TYPE" in
            node)
              if [ -d ".changeset" ]; then
                CHANGESET_COUNT=$(find .changeset -name "*.md" -not -name "README.md" 2>/dev/null | wc -l)
                if [ "$CHANGESET_COUNT" -gt 0 ]; then
                  HAS_CHANGESETS=true
                fi
              fi
              ;;
            python|go|java|rust)
              if [ -d ".changes" ]; then
                CHANGESET_COUNT=$(find .changes -type f 2>/dev/null | wc -l)
                if [ "$CHANGESET_COUNT" -gt 0 ]; then
                  HAS_CHANGESETS=true
                fi
              fi
              ;;
          esac
          
          echo "has_changesets=$HAS_CHANGESETS" >> $GITHUB_OUTPUT
          echo "skip_check=false" >> $GITHUB_OUTPUT
          echo "count=$CHANGESET_COUNT" >> $GITHUB_OUTPUT
          
          if [ "$HAS_CHANGESETS" = "true" ]; then
            echo "Found $CHANGESET_COUNT changesets"
          else
            echo "No changesets found"
          fi
      
      - name: Calculate version
        if: |
          steps.permissions.outputs.allowed == 'true' &&
          (steps.changesets.outputs.has_changesets == 'true' || 
           steps.parse.outputs.graduate == 'true' ||
           steps.changesets.outputs.skip_check == 'true')
        id: version
        shell: bash
        run: |
          SOURCE_BRANCH="${{ steps.branch.outputs.source_branch }}"
          PRERELEASE="${{ steps.parse.outputs.prerelease }}"
          GRADUATE="${{ steps.parse.outputs.graduate }}"
          FORCE_VERSION="${{ steps.parse.outputs.force_version }}"
          HAS_LOCK="${{ steps.lock.outputs.has_lock }}"
          SKIP_CHECK="${{ steps.changesets.outputs.skip_check }}"
          
          # If on release branch, use current package.json version
          if [ "$SKIP_CHECK" = "true" ] && [[ "$SOURCE_BRANCH" =~ ^release/ ]]; then
            CURRENT_VERSION=$(node -p "require('./package.json').version")
            
            # Add prerelease suffix if specified
            if [ -n "$PRERELEASE" ]; then
              # Check if version already has prerelease
              if [[ "$CURRENT_VERSION" =~ -([a-z]+)\.([0-9]+)$ ]]; then
                # Increment existing prerelease
                BASE_VERSION="${CURRENT_VERSION%%-*}"
                EXISTING_PRE="${BASH_REMATCH[1]}"
                EXISTING_NUM="${BASH_REMATCH[2]}"
                
                if [ "$EXISTING_PRE" = "$PRERELEASE" ]; then
                  NEW_NUM=$((EXISTING_NUM + 1))
                  NEW_VERSION="${BASE_VERSION}-${PRERELEASE}.${NEW_NUM}"
                else
                  NEW_VERSION="${BASE_VERSION}-${PRERELEASE}.0"
                fi
              else
                # Add new prerelease
                NEW_VERSION="${CURRENT_VERSION}-${PRERELEASE}.0"
              fi
              IS_PRERELEASE=true
            else
              # Use version as-is for stable release
              NEW_VERSION="$CURRENT_VERSION"
              IS_PRERELEASE=false
            fi
            
            echo "version=$NEW_VERSION" >> $GITHUB_OUTPUT
            echo "is_prerelease=$IS_PRERELEASE" >> $GITHUB_OUTPUT
            echo "ðŸ“¦ Using version from package.json: $NEW_VERSION"
            exit 0
          fi
          
          # Helper functions for Node.js projects
          get_current_version() {
            if [ -f "package.json" ]; then
              node -e "console.log(require('./package.json').version || '0.0.0')"
            else
              echo "0.0.0"
            fi
          }
          
          get_bump_type() {
            local bump="patch"
            
            if [ -d ".changeset" ]; then
              # Check for major changes
              if grep -l '"[^"]*": "major"' .changeset/*.md 2>/dev/null | grep -v README.md | head -1 > /dev/null; then
                bump="major"
              # Check for minor changes
              elif grep -l '"[^"]*": "minor"' .changeset/*.md 2>/dev/null | grep -v README.md | head -1 > /dev/null; then
                bump="minor"
              fi
            fi
            
            echo "$bump"
          }
          
          increment_version() {
            local version=$1
            local bump=$2
            
            # Remove any prerelease suffix
            version=${version%%-*}
            
            IFS='.' read -ra PARTS <<< "$version"
            local major="${PARTS[0]:-0}"
            local minor="${PARTS[1]:-0}"
            local patch="${PARTS[2]:-0}"
            
            case "$bump" in
              major)
                echo "$((major + 1)).0.0"
                ;;
              minor)
                echo "$major.$((minor + 1)).0"
                ;;
              patch)
                echo "$major.$minor.$((patch + 1))"
                ;;
              *)
                echo "$major.$minor.$patch"
                ;;
            esac
          }
          
          get_next_prerelease() {
            local base_version=$1
            local prerelease_type=$2
            
            # Check existing tags for this prerelease series
            local pattern="v${base_version}-${prerelease_type}."
            local latest_tag=$(git tag -l "${pattern}*" 2>/dev/null | sort -V | tail -1)
            
            if [ -z "$latest_tag" ]; then
              echo "${base_version}-${prerelease_type}.1"
            else
              # Extract counter and increment
              local counter=$(echo "$latest_tag" | grep -oE '[0-9]+$')
              echo "${base_version}-${prerelease_type}.$((counter + 1))"
            fi
          }
          
          # Main version calculation
          if [ "$GRADUATE" = "true" ]; then
            # Graduate prerelease to stable
            CURRENT_VERSION=$(get_current_version)
            # Remove prerelease suffix
            NEW_VERSION=${CURRENT_VERSION%%-*}
            IS_PRERELEASE=false
            
          elif [ "$FORCE_VERSION" != "" ]; then
            # Force specific version
            NEW_VERSION="$FORCE_VERSION"
            if [[ "$NEW_VERSION" == *"-"* ]]; then
              IS_PRERELEASE=true
            else
              IS_PRERELEASE=false
            fi
            
          elif [ "$HAS_LOCK" = "true" ] && [ "$PRERELEASE" != "" ]; then
            # Continue locked prerelease series
            LOCKED_VERSION="${{ steps.lock.outputs.locked_version }}"
            LOCKED_PRERELEASE="${{ steps.lock.outputs.locked_prerelease }}"
            LOCKED_COUNTER="${{ steps.lock.outputs.locked_counter }}"
            
            if [ "$PRERELEASE" = "$LOCKED_PRERELEASE" ]; then
              # Same prerelease type, increment counter
              NEW_VERSION="${LOCKED_VERSION}-${PRERELEASE}.$((LOCKED_COUNTER + 1))"
            else
              # Different prerelease type, start new series
              NEW_VERSION="${LOCKED_VERSION}-${PRERELEASE}.1"
            fi
            IS_PRERELEASE=true
            
          elif [ "$PRERELEASE" != "" ]; then
            # Start new prerelease series
            CURRENT_VERSION=$(get_current_version)
            BUMP_TYPE=$(get_bump_type)
            BASE_VERSION=$(increment_version "$CURRENT_VERSION" "$BUMP_TYPE")
            NEW_VERSION=$(get_next_prerelease "$BASE_VERSION" "$PRERELEASE")
            IS_PRERELEASE=true
            
          else
            # Regular release
            if [ "$HAS_LOCK" = "true" ]; then
              # Release the locked version
              NEW_VERSION="${{ steps.lock.outputs.locked_version }}"
            else
              # Calculate from changesets
              CURRENT_VERSION=$(get_current_version)
              BUMP_TYPE=$(get_bump_type)
              NEW_VERSION=$(increment_version "$CURRENT_VERSION" "$BUMP_TYPE")
            fi
            IS_PRERELEASE=false
          fi
          
          echo "version=$NEW_VERSION" >> $GITHUB_OUTPUT
          echo "is_prerelease=$IS_PRERELEASE" >> $GITHUB_OUTPUT
          echo "Calculated version: $NEW_VERSION (prerelease: $IS_PRERELEASE)"
      
      - name: Preview mode
        if: |
          steps.permissions.outputs.allowed == 'true' &&
          steps.parse.outputs.preview == 'true'
        uses: actions/github-script@v7
        with:
          script: |
            const version = '${{ steps.version.outputs.version }}';
            const changesetCount = '${{ steps.changesets.outputs.count }}';
            const projectType = '${{ steps.detect.outputs.project_type }}';
            const isPrerelease = '${{ steps.version.outputs.is_prerelease }}';
            
            let message = `ðŸ” **Release Preview**\n\n`;
            message += `**Version**: ${version || 'Unable to calculate'}\n`;
            message += `**Type**: ${isPrerelease === 'true' ? 'Pre-release' : 'Stable release'}\n`;
            message += `**Project**: ${projectType}\n`;
            message += `**Changesets**: ${changesetCount || '0'}\n\n`;
            
            if (!version) {
              message += `âš ï¸ Cannot proceed: ${changesetCount === '0' ? 'No changesets found' : 'Unable to calculate version'}`;
            } else {
              message += `This is a preview only. Remove \`--preview\` to execute the release.`;
            }
            
            await github.rest.issues.createComment({
              owner: context.repo.owner,
              repo: context.repo.repo,
              issue_number: context.issue.number,
              body: message
            });
      
      - name: Execute release
        if: |
          steps.permissions.outputs.allowed == 'true' &&
          steps.parse.outputs.preview != 'true' &&
          (steps.changesets.outputs.has_changesets == 'true' || 
           steps.parse.outputs.graduate == 'true' ||
           steps.changesets.outputs.skip_check == 'true')
        id: release
        shell: bash
        run: |
          VERSION="${{ steps.version.outputs.version }}"
          IS_PRERELEASE="${{ steps.version.outputs.is_prerelease }}"
          PRERELEASE="${{ steps.parse.outputs.prerelease }}"
          
          echo "Executing Node.js release for version $VERSION"
          echo "Is prerelease: ${IS_PRERELEASE:-false}"
          echo "Prerelease type: ${PRERELEASE:-none}"
          
          # Configure git
          git config user.name "github-actions[bot]"
          git config user.email "github-actions[bot]@users.noreply.github.com"
          
          # Verify version in package.json matches
          if [ -f "package.json" ]; then
            CURRENT_VERSION=$(node -p "require('./package.json').version")
            
            if [ "$CURRENT_VERSION" != "$VERSION" ]; then
              echo "Notice: package.json version ($CURRENT_VERSION) differs from release version ($VERSION)"
              
              if [ "$IS_PRERELEASE" = "true" ]; then
                echo "Creating prerelease $VERSION from base version $CURRENT_VERSION"
              else
                echo "Updating package.json to version $VERSION"
                node -e "
                  const fs = require('fs');
                  const pkg = JSON.parse(fs.readFileSync('package.json', 'utf8'));
                  pkg.version = '$VERSION';
                  fs.writeFileSync('package.json', JSON.stringify(pkg, null, 2) + '\\n');
                  console.log('Updated package.json to version ' + pkg.version);
                "
                
                # Update lock files if they exist
                if [ -f "pnpm-lock.yaml" ]; then
                  if command -v pnpm &> /dev/null; then
                    pnpm install --lockfile-only --silent
                    echo "Updated pnpm-lock.yaml"
                  fi
                fi
                
                # Commit changes
                git add package.json pnpm-lock.yaml 2>/dev/null || true
                git commit -m "chore(release): v$VERSION [skip ci]" || echo "No changes to commit"
              fi
            else
              echo "âœ“ package.json version is already $VERSION"
            fi
          fi
          
          # Create and push tag
          if git rev-parse "v$VERSION" >/dev/null 2>&1; then
            echo "âš ï¸ Tag v$VERSION already exists"
            if [ "$IS_PRERELEASE" != "true" ]; then
              echo "Updating tag to point to current commit (production release)"
              git tag -f "v$VERSION" -m "Release v$VERSION (production)"
              git push origin "v$VERSION" --force
            else
              echo "Skipping tag creation for prerelease (already exists)"
            fi
          else
            git tag "v$VERSION" -m "Release v$VERSION"
            git push origin "v$VERSION"
          fi
          
          # Push current branch
          git push origin HEAD
          
          echo "âœ… Node.js release completed for v$VERSION"
          echo "success=true" >> $GITHUB_OUTPUT
      
      - name: Update or create version lock
        if: |
          steps.permissions.outputs.allowed == 'true' &&
          steps.parse.outputs.preview != 'true' &&
          steps.parse.outputs.prerelease != '' &&
          steps.release.outputs.success == 'true'
        shell: bash
        run: |
          LOCK_FILE=".changeset/prerelease.lock"
          VERSION="${{ steps.version.outputs.version }}"
          PRERELEASE="${{ steps.parse.outputs.prerelease }}"
          
          # Extract base version and counter
          if [[ "$VERSION" =~ ^([0-9]+\.[0-9]+\.[0-9]+)-([a-z]+)\.([0-9]+)$ ]]; then
            BASE_VERSION="${BASH_REMATCH[1]}"
            COUNTER="${BASH_REMATCH[3]}"
            
            # Create or update lock file
            cat > "$LOCK_FILE" << EOF
          {
            "version": "$BASE_VERSION",
            "prerelease": "$PRERELEASE",
            "counter": $COUNTER,
            "createdAt": "$(date -u +"%Y-%m-%dT%H:%M:%SZ")"
          }
          EOF
            
            git add -f "$LOCK_FILE"  # Use -f to bypass .gitignore
            git diff --cached --quiet || git commit -m "chore: update version lock to $VERSION"
            git push
          fi
      
      - name: Clean changesets and remove lock
        if: |
          steps.permissions.outputs.allowed == 'true' &&
          steps.parse.outputs.preview != 'true' &&
          steps.parse.outputs.prerelease == '' &&
          steps.release.outputs.success == 'true'
        shell: bash
        run: |
          PROJECT_TYPE="${{ steps.detect.outputs.project_type }}"
          
          # Clean changesets based on project type
          case "$PROJECT_TYPE" in
            node)
              find .changeset -name "*.md" -not -name "README.md" -delete
              ;;
            *)
              rm -rf .changes/*
              ;;
          esac
          
          # Remove version lock if exists
          if [ -f ".changeset/prerelease.lock" ]; then
            rm ".changeset/prerelease.lock"
          fi
          
          git add .
          git diff --cached --quiet || git commit -m "chore: clean changesets after release"
          git push
          
          # Also clean lock file from develop branch
          echo "Cleaning prerelease.lock from develop branch..."
          git fetch origin develop
          git checkout develop
          if [ -f ".changeset/prerelease.lock" ]; then
            rm ".changeset/prerelease.lock"
            git add -f .changeset/prerelease.lock  # Use -f to bypass .gitignore
            git commit -m "chore: remove prerelease.lock after release"
            git push origin develop
          fi
          git checkout -
      
      - name: Create GitHub Release
        if: |
          steps.permissions.outputs.allowed == 'true' &&
          steps.parse.outputs.preview != 'true' &&
          steps.release.outputs.success == 'true'
        env:
          # Use PAT_TOKEN to trigger other workflows (like release-created.yml)
          GITHUB_TOKEN: ${{ secrets.PAT_TOKEN || secrets.GITHUB_TOKEN }}
        shell: bash
        run: |
          VERSION="${{ steps.version.outputs.version }}"
          IS_PRERELEASE="${{ steps.version.outputs.is_prerelease }}"
          
          # Read changelog content
          CHANGELOG_CONTENT="Release $VERSION"
          if [ -f "CHANGELOG.md" ]; then
            # Extract content for this version
            CHANGELOG_CONTENT=$(awk "/## $VERSION/,/^## [0-9]/" CHANGELOG.md | head -n -1)
          fi
          
          # Create release
          if [ "$IS_PRERELEASE" = "true" ]; then
            gh release create "v$VERSION" \
              --title "v$VERSION" \
              --notes "$CHANGELOG_CONTENT" \
              --prerelease \
              --target "${{ steps.branch.outputs.branch }}"
          else
            gh release create "v$VERSION" \
              --title "v$VERSION" \
              --notes "$CHANGELOG_CONTENT" \
              --latest \
              --target "${{ steps.branch.outputs.branch }}"
          fi
      
      - name: Post success comment
        if: |
          steps.permissions.outputs.allowed == 'true' &&
          steps.parse.outputs.preview != 'true' &&
          steps.release.outputs.success == 'true'
        uses: actions/github-script@v7
        with:
          script: |
            const version = '${{ steps.version.outputs.version }}';
            const isPrerelease = '${{ steps.version.outputs.is_prerelease }}';
            const emoji = isPrerelease === 'true' ? 'ðŸ·ï¸' : 'ðŸš€';
            const type = isPrerelease === 'true' ? 'Pre-release' : 'Release';
            
            await github.rest.issues.createComment({
              owner: context.repo.owner,
              repo: context.repo.repo,
              issue_number: context.issue.number,
              body: `${emoji} **${type} v${version} created successfully!**\n\nView the release: https://github.com/${context.repo.owner}/${context.repo.repo}/releases/tag/v${version}`
            });
            
            await github.rest.reactions.createForIssueComment({
              owner: context.repo.owner,
              repo: context.repo.repo,
              comment_id: context.payload.comment.id,
              content: 'rocket'
            });
      
      - name: Handle release failure
        if: |
          failure() &&
          steps.permissions.outputs.allowed == 'true' &&
          steps.parse.outputs.preview != 'true' &&
          (steps.changesets.outputs.has_changesets == 'true' || 
           steps.parse.outputs.graduate == 'true' ||
           steps.changesets.outputs.skip_check == 'true')
        uses: actions/github-script@v7
        with:
          script: |
            await github.rest.issues.createComment({
              owner: context.repo.owner,
              repo: context.repo.repo,
              issue_number: context.issue.number,
              body: `âŒ **Release failed**\n\nThe release process encountered an error. Please check the workflow logs for details.\n\nCommon issues:\n- Git configuration missing\n- Permission issues\n- Network problems\n\nYou can retry with \`/release ${{ steps.parse.outputs.prerelease || '' }}\``
            });
            
            await github.rest.reactions.createForIssueComment({
              owner: context.repo.owner,
              repo: context.repo.repo,
              comment_id: context.payload.comment.id,
              content: '-1'
            });
      
      - name: Handle no changesets
        if: |
          steps.permissions.outputs.allowed == 'true' &&
          steps.parse.outputs.preview != 'true' &&
          steps.changesets.outputs.has_changesets != 'true' &&
          steps.parse.outputs.graduate != 'true' &&
          steps.changesets.outputs.skip_check != 'true'
        uses: actions/github-script@v7
        with:
          script: |
            await github.rest.issues.createComment({
              owner: context.repo.owner,
              repo: context.repo.repo,
              issue_number: context.issue.number,
              body: `âš ï¸ **No changesets found**\n\nThere are no pending changesets to release. Please create changesets first using \`/changeset\` command.\n\nTo graduate a prerelease to stable, use \`/release --graduate\`.`
            });
            
            await github.rest.reactions.createForIssueComment({
              owner: context.repo.owner,
              repo: context.repo.repo,
              comment_id: context.payload.comment.id,
              content: 'confused'
            });