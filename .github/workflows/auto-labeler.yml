name: Auto Labeler

on:
  pull_request:
    types: [opened, reopened]
    branches: [develop, test, staging, main]

jobs:
  auto-label:
    name: Auto Label PR
    runs-on: ubuntu-latest
    permissions:
      pull-requests: write
      issues: write
    
    steps:
      - name: Checkout code
        uses: actions/checkout@v4

      - name: Analyze branch and apply labels
        uses: actions/github-script@v7
        with:
          github-token: ${{ secrets.GITHUB_TOKEN }}
          script: |
            const pr = context.payload.pull_request;
            const sourceBranch = pr.head.ref;
            const targetBranch = pr.base.ref;
            
            console.log(`üîç Analyzing PR: ${sourceBranch} ‚Üí ${targetBranch}`);
            
            // Parse branch name following pattern: {type}/#{issue}-{description}
            const branchPattern = /^(\w+)\/#?\d+-[\w-]+$/;
            const branchMatch = sourceBranch.match(branchPattern);
            
            if (!branchMatch) {
              console.log('‚ö†Ô∏è Branch name does not match expected pattern:', sourceBranch);
              return;
            }
            
            const branchType = branchMatch[1];
            console.log(`üîç Detected branch type: ${branchType}`);
            
            // Label rules based on branch type
            // Note: type: labels are already added by branch-validator.yml
            const branchRules = {
              'feature': {
                labels: ['changeset/minor', 'merge/squash'],
                publish: true
              },
              'fix': {
                labels: ['changeset/patch', 'merge/squash'],
                publish: true
              },
              'doc': {
                labels: ['changeset/none', 'merge/squash'],
                publish: false
              },
              'refactor': {
                labels: ['changeset/patch', 'merge/squash'],
                publish: true
              },
              'chore': {
                labels: ['changeset/none', 'merge/squash'],
                publish: false
              }
            };
            
            // Find matching rule
            const matchedRule = branchRules[branchType];
            
            if (!matchedRule) {
              console.log(`‚ö†Ô∏è No rule defined for branch type: ${branchType}`);
              return;
            }
            
            console.log(`‚úÖ Matched rule for type: ${branchType}`);
            
            // Get existing labels
            const { data: existingLabels } = await github.rest.issues.listLabelsOnIssue({
              owner: context.repo.owner,
              repo: context.repo.repo,
              issue_number: pr.number
            });
            
            const existingLabelNames = existingLabels.map(l => l.name);
            console.log('üìå Existing labels:', existingLabelNames);
            
            // Check for conflicting changeset labels
            const hasChangesetLabel = existingLabelNames.some(l => l.startsWith('changeset/'));
            const hasTypeLabel = existingLabelNames.some(l => l.startsWith('type:'));
            const hasMergeLabel = existingLabelNames.some(l => l.startsWith('merge/'));
            
            // Prepare labels to add
            let labelsToAdd = [...matchedRule.labels];
            
            // Add publish label based on target branch and changeset type
            if (matchedRule.publish) {
              const publishLabel = {
                'develop': 'publish/dev',
                'test': 'publish/alpha',
                'staging': 'publish/beta',
                'main': 'publish/latest'
              }[targetBranch];
              
              if (publishLabel) {
                labelsToAdd.push(publishLabel);
              }
            }
            
            // Filter out labels that would conflict
            if (hasChangesetLabel) {
              labelsToAdd = labelsToAdd.filter(l => !l.startsWith('changeset/'));
              console.log('‚ö†Ô∏è Skipping changeset label - already exists');
            }
            if (hasTypeLabel) {
              labelsToAdd = labelsToAdd.filter(l => !l.startsWith('type:'));
              console.log('‚ö†Ô∏è Skipping type label - already exists');
            }
            if (hasMergeLabel) {
              labelsToAdd = labelsToAdd.filter(l => !l.startsWith('merge/'));
              console.log('‚ö†Ô∏è Skipping merge label - already exists');
            }
            
            // Filter out already existing labels
            labelsToAdd = labelsToAdd.filter(l => !existingLabelNames.includes(l));
            
            if (labelsToAdd.length === 0) {
              console.log('‚ÑπÔ∏è No new labels to add');
              return;
            }
            
            console.log('üè∑Ô∏è Adding labels:', labelsToAdd);
            
            // Add the labels
            await github.rest.issues.addLabels({
              owner: context.repo.owner,
              repo: context.repo.repo,
              issue_number: pr.number,
              labels: labelsToAdd
            });
            
            // Add a comment explaining the auto-labeling
            const comment = `ü§ñ **Auto-labeler applied the following labels:**

${labelsToAdd.map(l => `- \`${l}\``).join('\n')}

**Based on:**
- Source branch: \`${sourceBranch}\`
- Target branch: \`${targetBranch}\`

${matchedRule.publish ? 'üì¶ This PR will be automatically published after merge.' : '‚è∏Ô∏è This PR will not trigger automatic publishing (changeset/none).'}

You can manually adjust these labels if needed.`;
            
            await github.rest.issues.createComment({
              owner: context.repo.owner,
              repo: context.repo.repo,
              issue_number: pr.number,
              body: comment
            });
            
            console.log('‚úÖ Auto-labeling complete!');