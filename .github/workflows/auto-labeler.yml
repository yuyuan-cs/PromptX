name: Auto Labeler

on:
  pull_request:
    types: [opened, reopened]
    branches: [develop, test, staging, main]

jobs:
  auto-label:
    name: Auto Label PR
    runs-on: ubuntu-latest
    permissions:
      pull-requests: write
      issues: write
    
    steps:
      - name: Checkout code
        uses: actions/checkout@v4

      - name: Analyze branch and apply labels
        uses: actions/github-script@v7
        with:
          github-token: ${{ secrets.GITHUB_TOKEN }}
          script: |
            const pr = context.payload.pull_request;
            const sourceBranch = pr.head.ref;
            const targetBranch = pr.base.ref;
            const prTitle = pr.title;
            
            console.log(`ğŸ” Analyzing PR: ${sourceBranch} â†’ ${targetBranch}`);
            console.log(`ğŸ“ PR Title: ${prTitle}`);
            
            // First try to parse PR title for conventional commit format
            const titlePattern = /^(feat|fix|docs|style|refactor|perf|test|build|ci|chore|revert)(\(.+\))?(!)?:\s*(.+)/;
            const titleMatch = prTitle.match(titlePattern);
            
            // Parse branch name as fallback
            const branchPattern = /^(\w+)\/#?\d+-[\w-]+$/;
            const branchMatch = sourceBranch.match(branchPattern);
            
            // Determine the type from PR title or branch name
            let detectedType;
            let isBreakingChange = false;
            
            if (titleMatch) {
              detectedType = titleMatch[1];
              isBreakingChange = titleMatch[3] === '!';
              console.log(`âœ… Detected type from PR title: ${detectedType}${isBreakingChange ? ' (BREAKING)' : ''}`);
            } else if (branchMatch) {
              detectedType = branchMatch[1];
              console.log(`ğŸ” Detected type from branch: ${detectedType}`);
            } else {
              console.log('âš ï¸ Could not determine type from PR title or branch name');
              return;
            }
            
            // Label rules based on detected type
            // Priority: PR title > branch name
            const typeRules = {
              'feat': {
                labels: [isBreakingChange ? 'changeset/major' : 'changeset/minor', 'merge/squash']
              },
              'feature': {  // Support branch naming
                labels: ['changeset/minor', 'merge/squash']
              },
              'fix': {
                labels: ['changeset/patch', 'merge/squash']
              },
              'docs': {
                labels: ['changeset/none', 'merge/squash']
              },
              'doc': {  // Support branch naming
                labels: ['changeset/none', 'merge/squash']
              },
              'style': {
                labels: ['changeset/none', 'merge/squash']
              },
              'refactor': {
                labels: ['changeset/patch', 'merge/squash']
              },
              'perf': {
                labels: ['changeset/patch', 'merge/squash']
              },
              'test': {
                labels: ['changeset/none', 'merge/squash']
              },
              'build': {
                labels: ['changeset/patch', 'merge/squash']
              },
              'ci': {
                labels: ['changeset/none', 'merge/squash']
              },
              'chore': {
                labels: ['changeset/none', 'merge/squash']
              },
              'revert': {
                labels: ['changeset/patch', 'merge/squash']
              }
            };
            
            // Find matching rule
            const matchedRule = typeRules[detectedType];
            
            if (!matchedRule) {
              console.log(`âš ï¸ No rule defined for type: ${detectedType}`);
              // Default to no version change for unknown types
              const defaultRule = {
                labels: ['changeset/none', 'merge/squash']
              };
              matchedRule = defaultRule;
            }
            
            console.log(`âœ… Matched rule for type: ${detectedType}`);
            
            // Get existing labels
            const { data: existingLabels } = await github.rest.issues.listLabelsOnIssue({
              owner: context.repo.owner,
              repo: context.repo.repo,
              issue_number: pr.number
            });
            
            const existingLabelNames = existingLabels.map(l => l.name);
            console.log('ğŸ“Œ Existing labels:', existingLabelNames);
            
            // Check for conflicting changeset labels
            const hasChangesetLabel = existingLabelNames.some(l => l.startsWith('changeset/'));
            const hasTypeLabel = existingLabelNames.some(l => l.startsWith('type:'));
            const hasMergeLabel = existingLabelNames.some(l => l.startsWith('merge/'));
            
            // Prepare labels to add
            let labelsToAdd = [...matchedRule.labels];
            
            // Filter out labels that would conflict
            if (hasChangesetLabel) {
              labelsToAdd = labelsToAdd.filter(l => !l.startsWith('changeset/'));
              console.log('âš ï¸ Skipping changeset label - already exists');
            }
            if (hasTypeLabel) {
              labelsToAdd = labelsToAdd.filter(l => !l.startsWith('type:'));
              console.log('âš ï¸ Skipping type label - already exists');
            }
            if (hasMergeLabel) {
              labelsToAdd = labelsToAdd.filter(l => !l.startsWith('merge/'));
              console.log('âš ï¸ Skipping merge label - already exists');
            }
            
            // Filter out already existing labels
            labelsToAdd = labelsToAdd.filter(l => !existingLabelNames.includes(l));
            
            if (labelsToAdd.length === 0) {
              console.log('â„¹ï¸ No new labels to add');
              return;
            }
            
            console.log('ğŸ·ï¸ Adding labels:', labelsToAdd);
            
            // Add publish label based on target branch and changeset label
            const hasVersionChange = !labelsToAdd.includes('changeset/none') && !existingLabelNames.includes('changeset/none');
            
            if (hasVersionChange) {
              // Add publish label based on target branch
              let publishLabel = null;
              switch(targetBranch) {
                case 'develop':
                  publishLabel = 'publish/dev';
                  break;
                case 'test':
                  publishLabel = 'publish/alpha';
                  break;
                case 'staging':
                  publishLabel = 'publish/beta';
                  break;
                case 'main':
                  publishLabel = 'publish/latest';
                  break;
              }
              
              if (publishLabel && !existingLabelNames.includes(publishLabel)) {
                labelsToAdd.push(publishLabel);
                console.log(`ğŸš€ Adding publish label: ${publishLabel}`);
              }
            }
            
            // Add the labels
            await github.rest.issues.addLabels({
              owner: context.repo.owner,
              repo: context.repo.repo,
              issue_number: pr.number,
              labels: labelsToAdd
            });
            
            // Add a comment explaining the auto-labeling
            let commentBody = 'ğŸ¤– **Auto-labeler applied the following labels:**\n\n';
            commentBody += labelsToAdd.map(l => '- `' + l + '`').join('\n');
            commentBody += '\n\n**Based on:**\n';
            commentBody += `- Source branch: \`${sourceBranch}\`\n`;
            commentBody += `- Target branch: \`${targetBranch}\`\n\n`;
            
            const hasChangesetNone = labelsToAdd.includes('changeset/none') || existingLabelNames.includes('changeset/none');
            const hasPublishLabel = labelsToAdd.some(l => l.startsWith('publish/'));
            
            if (hasPublishLabel) {
              const publishTag = labelsToAdd.find(l => l.startsWith('publish/')).replace('publish/', '');
              commentBody += `ğŸ“¦ Version will be published to **${publishTag}** tag after merge.\n\n`;
            } else if (!hasChangesetNone) {
              commentBody += 'ğŸ“¦ Version will be updated but not published (no publish label).\n\n';
            } else {
              commentBody += 'â¸ï¸ No version change needed (changeset/none).\n\n';
            }
            
            commentBody += 'You can manually adjust these labels if needed.';
            
            await github.rest.issues.createComment({
              owner: context.repo.owner,
              repo: context.repo.repo,
              issue_number: pr.number,
              body: commentBody
            });
            
            console.log('âœ… Auto-labeling complete!');