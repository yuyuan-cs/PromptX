name: Changeset Command

on:
  issue_comment:
    types: [created]

jobs:
  handle-changeset:
    if: |
      github.event.issue.pull_request &&
      startsWith(github.event.comment.body, '/changeset')
    runs-on: ubuntu-latest
    
    permissions:
      contents: write
      pull-requests: write
      issues: write
    
    steps:
      - name: Check permissions
        id: permissions
        uses: actions/github-script@v7
        with:
          script: |
            const username = context.payload.comment.user.login;
            console.log(`Checking permissions for user: ${username}`);
            
            // Allow github-actions bot for automated workflows
            if (username === 'github-actions[bot]' || username === 'github-actions') {
              console.log('Allowing github-actions bot');
              core.setOutput('allowed', true);
              return;
            }
            
            try {
              // Get user's permission level
              const { data: perm } = await github.rest.repos.getCollaboratorPermissionLevel({
                owner: context.repo.owner,
                repo: context.repo.repo,
                username: username
              });
              
              const hasPermission = ['admin', 'maintain', 'write'].includes(perm.permission);
              core.setOutput('allowed', hasPermission);
              
              if (!hasPermission) {
                await github.rest.issues.createComment({
                  owner: context.repo.owner,
                  repo: context.repo.repo,
                  issue_number: context.issue.number,
                  body: `‚ùå **Permission denied**\n\n@${username} does not have permission to create changesets. Only contributors with write access can use the \`/changeset\` command.`
                });
                
                await github.rest.reactions.createForIssueComment({
                  owner: context.repo.owner,
                  repo: context.repo.repo,
                  comment_id: context.payload.comment.id,
                  content: '-1'
                });
              }
            } catch (error) {
              core.setOutput('allowed', false);
              console.error('Permission check failed:', error);
            }
      
      - name: Get PR Details
        if: steps.permissions.outputs.allowed == 'true'
        id: pr
        uses: actions/github-script@v7
        with:
          script: |
            const pr = await github.rest.pulls.get({
              owner: context.repo.owner,
              repo: context.repo.repo,
              pull_number: context.issue.number
            });
            
            core.setOutput('branch', pr.data.head.ref);
            core.setOutput('title', pr.data.title);
            core.setOutput('author', pr.data.user.login);
            core.setOutput('number', context.issue.number);
            
            // Add eyes reaction to show command received
            await github.rest.reactions.createForIssueComment({
              owner: context.repo.owner,
              repo: context.repo.repo,
              comment_id: context.payload.comment.id,
              content: 'eyes'
            });
      
      - name: Checkout PR Branch
        if: steps.permissions.outputs.allowed == 'true'
        uses: actions/checkout@v4
        with:
          token: ${{ secrets.GITHUB_TOKEN }}
          ref: ${{ steps.pr.outputs.branch }}
          fetch-depth: 0
      
      - name: Configure Git
        if: steps.permissions.outputs.allowed == 'true'
        run: |
          git config --global user.name "github-actions[bot]"
          git config --global user.email "github-actions[bot]@users.noreply.github.com"
      
      - name: Parse Command
        if: steps.permissions.outputs.allowed == 'true'
        id: parse
        shell: bash
        run: |
          COMMAND="${{ github.event.comment.body }}"
          echo "Raw command: $COMMAND"
          
          # Parse: /changeset [--auto|patch|minor|major] [optional message]
          # Default to --auto if no arguments provided
          if [[ "$COMMAND" == "/changeset" ]]; then
            # No arguments = auto mode
            echo "mode=auto" >> $GITHUB_OUTPUT
            echo "valid=true" >> $GITHUB_OUTPUT
            echo "Auto mode: will analyze commits to determine version"
          elif [[ "$COMMAND" =~ ^/changeset[[:space:]]+--auto([[:space:]]+(.*))?$ ]]; then
            # Explicit auto mode
            MESSAGE="${BASH_REMATCH[2]}"
            echo "mode=auto" >> $GITHUB_OUTPUT
            echo "message=$MESSAGE" >> $GITHUB_OUTPUT
            echo "valid=true" >> $GITHUB_OUTPUT
            echo "Auto mode with message: $MESSAGE"
          elif [[ "$COMMAND" =~ ^/changeset[[:space:]]+(patch|minor|major)([[:space:]]+(.*))?$ ]]; then
            # Manual mode with explicit version
            TYPE="${BASH_REMATCH[1]}"
            MESSAGE="${BASH_REMATCH[3]}"
            
            echo "mode=manual" >> $GITHUB_OUTPUT
            echo "type=$TYPE" >> $GITHUB_OUTPUT
            echo "message=$MESSAGE" >> $GITHUB_OUTPUT
            echo "valid=true" >> $GITHUB_OUTPUT
            
            echo "Manual mode: type=$TYPE, message=$MESSAGE"
          else
            echo "valid=false" >> $GITHUB_OUTPUT
            echo "Invalid command format"
          fi
      
      - name: Check and Remove Existing Changeset
        if: steps.permissions.outputs.allowed == 'true' && steps.parse.outputs.valid == 'true'
        id: check
        shell: bash
        run: |
          PR_NUMBER="${{ steps.pr.outputs.number }}"
          
          # Check for existing changeset files in various formats
          FOUND=false
          REMOVED_FILES=""
          
          # Node.js changeset
          for file in .changeset/*-pr-${PR_NUMBER}-*.md .changeset/*pr-${PR_NUMBER}*.md; do
            if [ -f "$file" ]; then
              echo "Found existing Node.js changeset: $file"
              git rm "$file" 2>/dev/null || rm "$file"
              REMOVED_FILES="${REMOVED_FILES} $(basename $file)"
              FOUND=true
            fi
          done
          
          # Python/Go/Generic changes
          for file in .changes/*${PR_NUMBER}*; do
            if [ -f "$file" ]; then
              echo "Found existing changeset: $file"
              git rm "$file" 2>/dev/null || rm "$file"
              REMOVED_FILES="${REMOVED_FILES} $(basename $file)"
              FOUND=true
            fi
          done
          
          if [ "$FOUND" = "true" ]; then
            echo "exists=true" >> $GITHUB_OUTPUT
            echo "removed_files=$REMOVED_FILES" >> $GITHUB_OUTPUT
            echo "‚úÖ Removed existing changesets: $REMOVED_FILES"
          else
            echo "exists=false" >> $GITHUB_OUTPUT
            echo "No existing changeset for PR #${PR_NUMBER}"
          fi
      
      - name: Analyze Version Type (Auto Mode)
        if: steps.permissions.outputs.allowed == 'true' && steps.parse.outputs.mode == 'auto'
        id: analyze
        shell: bash
        run: |
          echo "üîç Analyzing commits to determine version type..."
          
          # Get base branch
          BASE_BRANCH=$(gh pr view ${{ steps.pr.outputs.number }} --json baseRefName -q .baseRefName)
          
          # Analyze commits between base and head
          VERSION_TYPE="patch"
          CHANGES=""
          
          # Get all commits in this PR
          COMMITS=$(git log origin/${BASE_BRANCH}..HEAD --oneline)
          
          while IFS= read -r commit; do
            echo "Analyzing: $commit"
            
            # Check for breaking changes (major)
            if echo "$commit" | grep -qE "(BREAKING CHANGE:|!:)"; then
              VERSION_TYPE="major"
              CHANGES="${CHANGES}\nüí• Breaking: ${commit}"
              continue
            fi
            
            # Extract commit type using unified regex
            COMMIT_TYPE=$(echo "$commit" | sed -nE 's/^[a-f0-9]+ (feat|fix|docs|style|refactor|perf|test|chore|build|ci|revert|enhance)(\(.+?\))?:.*/\1/p')
            
            if [ -n "$COMMIT_TYPE" ]; then
              case "$COMMIT_TYPE" in
                # Minor version bumps
                feat|enhance)
                  if [ "$VERSION_TYPE" != "major" ]; then
                    VERSION_TYPE="minor"
                  fi
                  EMOJI="‚ú®"
                  [ "$COMMIT_TYPE" == "enhance" ] && EMOJI="üé®"
                  CHANGES="${CHANGES}\n${EMOJI} ${COMMIT_TYPE^}: ${commit}"
                  ;;
                
                # Patch version bumps  
                fix)
                  CHANGES="${CHANGES}\nüêõ Fix: ${commit}"
                  ;;
                perf)
                  CHANGES="${CHANGES}\n‚ö° Performance: ${commit}"
                  ;;
                refactor)
                  CHANGES="${CHANGES}\n‚ôªÔ∏è Refactor: ${commit}"
                  ;;
                docs)
                  CHANGES="${CHANGES}\nüìù Docs: ${commit}"
                  ;;
                style)
                  CHANGES="${CHANGES}\nüíÑ Style: ${commit}"
                  ;;
                test)
                  CHANGES="${CHANGES}\n‚úÖ Test: ${commit}"
                  ;;
                chore)
                  CHANGES="${CHANGES}\nüîß Chore: ${commit}"
                  ;;
                build)
                  CHANGES="${CHANGES}\nüì¶ Build: ${commit}"
                  ;;
                ci)
                  CHANGES="${CHANGES}\nüë∑ CI: ${commit}"
                  ;;
                revert)
                  CHANGES="${CHANGES}\n‚è™ Revert: ${commit}"
                  ;;
              esac
            fi
          done <<< "$COMMITS"
          
          # If no conventional commits found, analyze files
          if [ "$VERSION_TYPE" == "patch" ]; then
            FILES_CHANGED=$(git diff origin/${BASE_BRANCH}..HEAD --name-only)
            
            # Check if only docs/tests changed
            ONLY_DOCS_TESTS=true
            while IFS= read -r file; do
              if [[ ! "$file" =~ (README|docs/|test/|\.md$|\.test\.|\.spec\.) ]]; then
                ONLY_DOCS_TESTS=false
                break
              fi
            done <<< "$FILES_CHANGED"
            
            if [ "$ONLY_DOCS_TESTS" == "true" ]; then
              echo "Only documentation or tests changed, using patch"
            fi
          fi
          
          echo "type=$VERSION_TYPE" >> $GITHUB_OUTPUT
          echo "changes=$CHANGES" >> $GITHUB_OUTPUT
          echo "‚úÖ Determined version type: $VERSION_TYPE"
        env:
          GH_TOKEN: ${{ secrets.GITHUB_TOKEN }}
      
      - name: Detect Project Type
        if: steps.permissions.outputs.allowed == 'true' && steps.parse.outputs.valid == 'true'
        id: detect
        shell: bash
        run: |
          # Detect project type inline
          if [ -f "package.json" ]; then
            PROJECT_TYPE="node"
          elif [ -f "pyproject.toml" ] || [ -f "setup.py" ]; then
            PROJECT_TYPE="python"
          elif [ -f "go.mod" ]; then
            PROJECT_TYPE="go"
          elif [ -f "pom.xml" ]; then
            PROJECT_TYPE="java-maven"
          elif [ -f "build.gradle" ] || [ -f "build.gradle.kts" ]; then
            PROJECT_TYPE="java-gradle"
          elif [ -f "Cargo.toml" ]; then
            PROJECT_TYPE="rust"
          elif [ -f "composer.json" ]; then
            PROJECT_TYPE="php"
          elif [ -f "Gemfile" ]; then
            PROJECT_TYPE="ruby"
          else
            PROJECT_TYPE="unknown"
          fi
          
          echo "project_type=$PROJECT_TYPE" >> $GITHUB_OUTPUT
          echo "Detected project type: $PROJECT_TYPE"
      
      - name: Create Changeset File
        if: |
          steps.permissions.outputs.allowed == 'true' &&
          steps.parse.outputs.valid == 'true'
        shell: bash
        run: |
          # Determine version type based on mode
          if [ "${{ steps.parse.outputs.mode }}" == "auto" ]; then
            TYPE="${{ steps.analyze.outputs.type }}"
            echo "Using auto-detected type: $TYPE"
          else
            TYPE="${{ steps.parse.outputs.type }}"
            echo "Using manually specified type: $TYPE"
          fi
          
          MESSAGE="${{ steps.parse.outputs.message }}"
          PR_TITLE="${{ steps.pr.outputs.title }}"
          PR_NUMBER="${{ steps.pr.outputs.number }}"
          PR_AUTHOR="${{ steps.pr.outputs.author }}"
          PROJECT_TYPE="${{ steps.detect.outputs.project_type }}"
          
          # Use custom message or PR title
          CHANGESET_MESSAGE="${MESSAGE:-$PR_TITLE}"
          
          # Handle Node.js project directly (since PromptX is a Node project)
          if [ "$PROJECT_TYPE" == "node" ]; then
            # Check if changesets is configured
            if [ ! -f ".changeset/config.json" ]; then
              echo "Changesets not configured. Run: npx changeset init"
              exit 1
            fi
            
            # Create changeset file
            TIMESTAMP=$(date +%s)
            FILENAME=".changeset/${TIMESTAMP}-pr-${PR_NUMBER}-${TYPE}.md"
            
            # Get package name from package.json
            PACKAGE_NAME=$(node -e "console.log(require('./package.json').name || '@unknown/package')")
            
            # Create changeset content
            cat > "$FILENAME" << EOF
---
"${PACKAGE_NAME}": ${TYPE}
---

${CHANGESET_MESSAGE}

Contributed by @${PR_AUTHOR} via #${PR_NUMBER}
EOF
            
            echo "Created Node.js changeset: $FILENAME"
          else
            echo "Project type $PROJECT_TYPE is not Node.js, skipping changeset creation"
            exit 1
          fi
          
          echo "changeset_created=true" >> $GITHUB_OUTPUT
      
      - name: Commit and Push
        if: |
          steps.permissions.outputs.allowed == 'true' &&
          steps.parse.outputs.valid == 'true'
        shell: bash
        run: |
          git config user.name "github-actions[bot]"
          git config user.email "github-actions[bot]@users.noreply.github.com"
          
          # Add both .changeset and .changes directories (one will exist based on project type)
          git add .changeset/ 2>/dev/null || true
          git add .changes/ 2>/dev/null || true
          
          # Determine commit message based on whether we're updating or creating
          if [ "${{ steps.check.outputs.exists }}" == "true" ]; then
            COMMIT_MSG="üì¶ Update changeset for PR #${{ steps.pr.outputs.number }}"
          else
            COMMIT_MSG="üì¶ Add changeset for PR #${{ steps.pr.outputs.number }}"
          fi
          
          git commit -m "$COMMIT_MSG"
          git push origin ${{ steps.pr.outputs.branch }}
      
      - name: Post Success Comment
        if: |
          steps.permissions.outputs.allowed == 'true' &&
          steps.parse.outputs.valid == 'true'
        uses: actions/github-script@v7
        env:
          PARSE_MODE: ${{ steps.parse.outputs.mode }}
          ANALYZE_TYPE: ${{ steps.analyze.outputs.type }}
          PARSE_TYPE: ${{ steps.parse.outputs.type }}
          CHECK_EXISTS: ${{ steps.check.outputs.exists }}
          REMOVED_FILES: ${{ steps.check.outputs.removed_files }}
          ANALYZE_CHANGES: ${{ steps.analyze.outputs.changes }}
        with:
          script: |
            const mode = process.env.PARSE_MODE;
            const type = mode === 'auto' ? process.env.ANALYZE_TYPE : process.env.PARSE_TYPE;
            const existed = process.env.CHECK_EXISTS === 'true';
            const emoji = {
              'patch': 'ü©π',
              'minor': '‚ú®',
              'major': 'üí•'
            }[type];
            
            const action = existed ? 'Updated' : 'Created';
            let message = `${emoji} **${action} ${type} changeset**\n\n`;
            
            if (existed) {
              const removedFiles = process.env.REMOVED_FILES;
              if (removedFiles) {
                message += `üìù **Replaced previous changeset(s):** ${removedFiles}\n\n`;
              }
            }
            
            if (mode === 'auto') {
              message += `ü§ñ **Auto-detected version type based on commit analysis**\n\n`;
              const changes = process.env.ANALYZE_CHANGES;
              if (changes) {
                message += `**Detected changes:**\n${changes}\n\n`;
              }
            }
            
            message += `This PR will trigger a ${type} version bump when merged.`;
            
            if (mode === 'auto') {
              message += `\n\nüí° _Tip: You can override this by running \`/changeset [patch|minor|major]\` manually._`;
            }
            
            await github.rest.issues.createComment({
              owner: context.repo.owner,
              repo: context.repo.repo,
              issue_number: context.issue.number,
              body: message
            });
            
            // Add rocket reaction for success
            await github.rest.reactions.createForIssueComment({
              owner: context.repo.owner,
              repo: context.repo.repo,
              comment_id: context.payload.comment.id,
              content: 'rocket'
            });
      
      - name: Post Error Comment
        if: steps.permissions.outputs.allowed == 'true' && steps.parse.outputs.valid == 'false'
        uses: actions/github-script@v7
        with:
          script: |
            await github.rest.issues.createComment({
              owner: context.repo.owner,
              repo: context.repo.repo,
              issue_number: context.issue.number,
              body: `‚ùå **Invalid command format**\n\nUsage: \`/changeset [--auto|patch|minor|major] [optional message]\`\n\nExamples:\n- \`/changeset\` - Auto-detect version from commits (default)\n- \`/changeset --auto\` - Explicitly use auto mode\n- \`/changeset patch\` - Manual patch version\n- \`/changeset minor Add dark mode support\` - Manual minor with message\n- \`/changeset major Breaking API changes\` - Manual major with message`
            });
            
            // Add confused reaction for error
            await github.rest.reactions.createForIssueComment({
              owner: context.repo.owner,
              repo: context.repo.repo,
              comment_id: context.payload.comment.id,
              content: 'confused'
            });
      
