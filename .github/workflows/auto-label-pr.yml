name: Auto Label PR

on:
  pull_request:
    types: [opened, synchronize]

jobs:
  label:
    runs-on: ubuntu-latest
    permissions:
      contents: read
      pull-requests: write
      
    steps:
      - name: Checkout repository
        uses: actions/checkout@v4
        with:
          fetch-depth: 0
          
      - name: Get changed files
        id: changed-files
        uses: actions/github-script@v7
        with:
          script: |
            const { data: files } = await github.rest.pulls.listFiles({
              owner: context.repo.owner,
              repo: context.repo.repo,
              pull_number: context.issue.number
            });
            
            const changedFiles = files.map(f => f.filename);
            console.log('Changed files:', changedFiles);
            
            // æ·»åŠ è¯¦ç»†çš„æ–‡ä»¶ç»Ÿè®¡
            const fileStats = {
              total: changedFiles.length,
              docs: 0,
              config: 0,
              core: 0,
              prompt: 0,
              test: 0,
              other: 0
            };
            
            // æ£€æŸ¥æ˜¯å¦åªåŒ…å«æ–‡æ¡£å’Œé…ç½®æ–‡ä»¶
            const docsAndConfigPaths = [
              /^README.*\.md$/,
              /^CHANGELOG\.md$/,
              /^CONTRIBUTING\.md$/,
              /^LICENSE/,
              /^docs\//,
              /^assets\//,
              /^\.github\//,
              /^examples\//,
              /^\.gitignore$/,
              /^\.npmignore$/,
              /^\.editorconfig$/,
              /^\.(eslintrc|prettierrc|babelrc)/
            ];
            
            const isDocsOrConfig = changedFiles.every(path => 
              docsAndConfigPaths.some(pattern => pattern.test(path))
            );
            
            // æ£€æŸ¥æ˜¯å¦åŒ…å«æç¤ºè¯æ–‡ä»¶ï¼ˆåœ¨ prompt ç›®å½•ä¸‹çš„ .md æ–‡ä»¶ï¼‰
            const hasPromptFiles = changedFiles.some(path => 
              path.startsWith('prompt/') && path.endsWith('.md')
            );
            
            // æ£€æŸ¥æ˜¯å¦åŒ…å«æ ¸å¿ƒä»£ç å˜æ›´
            const hasCoreChanges = changedFiles.some(path => 
              path.endsWith('.js') || 
              path.endsWith('.ts') || 
              path.endsWith('.json') && !path.includes('.github/') ||
              path.startsWith('src/') ||
              path.startsWith('lib/') ||
              path === 'package.json'
            );
            
            return {
              isDocsOrConfig,
              hasPromptFiles,
              hasCoreChanges,
              fileCount: changedFiles.length,
              files: changedFiles
            };
            
      - name: Apply labels
        uses: actions/github-script@v7
        with:
          github-token: ${{ secrets.GH_PAT || github.token }}
          script: |
            const result = ${{ steps.changed-files.outputs.result }};
            const labels = [];
            
            // è¾“å‡ºè°ƒè¯•ä¿¡æ¯
            console.log('Analysis result:', JSON.stringify(result, null, 2));
            
            // å¤„ç†ä¸åŒç±»å‹çš„å˜æ›´ç»„åˆ
            if (result.hasCoreChanges) {
              labels.push('core-changes');
              // æœ‰æ ¸å¿ƒä»£ç å˜æ›´æ—¶ï¼Œéœ€è¦å‘ç‰ˆ
            }
            
            if (result.hasPromptFiles) {
              labels.push('prompt-update');
              // æç¤ºè¯æ›´æ–°éœ€è¦å‘ç‰ˆ
            }
            
            if (result.isDocsOrConfig && !result.hasPromptFiles) {
              // çº¯æ–‡æ¡£/é…ç½®ä¿®æ”¹
              labels.push('documentation');
              labels.push('skip-release');
            } else if (!result.hasCoreChanges && !result.hasPromptFiles) {
              // æ—¢ä¸æ˜¯çº¯æ–‡æ¡£ï¼Œä¹Ÿæ²¡æœ‰æ ¸å¿ƒä»£ç å’Œæç¤ºè¯å˜æ›´
              // å¯èƒ½æ˜¯æµ‹è¯•æ–‡ä»¶ç­‰ï¼Œæ ¹æ®å…·ä½“æƒ…å†µå†³å®š
              const hasTestChanges = result.files.some(path => 
                path.includes('test/') || path.includes('__tests__/') || 
                path.endsWith('.test.js') || path.endsWith('.spec.js')
              );
              if (hasTestChanges) {
                labels.push('test');
                // æµ‹è¯•æ–‡ä»¶ä¿®æ”¹é€šå¸¸ä¸éœ€è¦å‘ç‰ˆï¼Œé™¤éåŒæ—¶æœ‰ä»£ç ä¿®æ”¹
              }
            }
            
            // å®šä¹‰æ–‡æ¡£å’Œé…ç½®æ–‡ä»¶çš„æ¨¡å¼
            const docsConfigPatterns = [
              /^README.*\.md$/,
              /^CHANGELOG\.md$/,
              /^CONTRIBUTING\.md$/,
              /^LICENSE/,
              /^docs\//,
              /^assets\//,
              /^\.github\//,
              /^examples\//,
              /^\.gitignore$/,
              /^\.npmignore$/,
              /^\.editorconfig$/,
              /^\.(eslintrc|prettierrc|babelrc)/
            ];
            
            // æ£€æŸ¥æ˜¯å¦æœ‰æ–‡æ¡£/é…ç½®æ–‡ä»¶å˜æ›´
            const hasDocsOrConfigChanges = result.files.some(path => 
              docsConfigPatterns.some(pattern => pattern.test(path))
            );
            
            // æ·»åŠ æ··åˆå˜æ›´æ ‡ç­¾
            if (result.hasCoreChanges && hasDocsOrConfigChanges) {
              labels.push('mixed-changes');
              // æ··åˆå˜æ›´æ—¶ï¼Œä»¥ä»£ç å˜æ›´ä¸ºå‡†ï¼Œéœ€è¦å‘ç‰ˆ
            }
            
            // æ ¹æ® PR æ ‡é¢˜æ·»åŠ æ ‡ç­¾
            const title = context.payload.pull_request.title.toLowerCase();
            if (title.includes('chore:') || title.includes('chore(')) {
              labels.push('chore');
              if (!result.hasCoreChanges) {
                labels.push('skip-release');
              }
            }
            
            if (title.includes('docs:') || title.includes('doc:')) {
              labels.push('documentation');
              if (!result.hasCoreChanges && !result.hasPromptFiles) {
                labels.push('skip-release');
              }
            }
            
            if (title.includes('ci:') || title.includes('workflow:')) {
              labels.push('ci/cd');
              if (!result.hasCoreChanges && !result.hasPromptFiles) {
                labels.push('skip-release');
              }
            }
            
            if (labels.length > 0) {
              await github.rest.issues.addLabels({
                owner: context.repo.owner,
                repo: context.repo.repo,
                issue_number: context.issue.number,
                labels: labels
              });
              console.log(`Applied labels: ${labels.join(', ')}`);
            }
            
            // å¯¹æ··åˆå˜æ›´çš„ PR æ·»åŠ è¯´æ˜è¯„è®º
            if (result.hasCoreChanges && (result.isDocsOrConfig || labels.includes('documentation'))) {
              const skipRelease = labels.includes('skip-release');
              const comment = `## ğŸ“Š å˜æ›´åˆ†ææŠ¥å‘Š
              
æœ¬ PR åŒ…å«äº†**æ··åˆç±»å‹**çš„å˜æ›´ï¼š
- âœ… æ ¸å¿ƒä»£ç å˜æ›´
- ğŸ“š æ–‡æ¡£/é…ç½®å˜æ›´

**ç‰ˆæœ¬å‘å¸ƒå†³ç­–**: ${skipRelease ? 'â­ï¸ è·³è¿‡ç‰ˆæœ¬å‘å¸ƒ' : 'ğŸš€ å°†è§¦å‘ç‰ˆæœ¬å‘å¸ƒ'}

> ğŸ’¡ æç¤ºï¼šå¦‚æœæ‚¨åªæƒ³æ›´æ–°æ–‡æ¡£è€Œä¸å‘ç‰ˆï¼Œè¯·å°†ä»£ç å’Œæ–‡æ¡£å˜æ›´åˆ†å¼€åˆ°ä¸åŒçš„ PR ä¸­ã€‚`;
              
              try {
                await github.rest.issues.createComment({
                  owner: context.repo.owner,
                  repo: context.repo.repo,
                  issue_number: context.issue.number,
                  body: comment
                });
              } catch (error) {
                console.log('Failed to create comment:', error);
              }
            }