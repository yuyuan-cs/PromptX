name: 'Deploy Command'

on:
  issue_comment:
    types: [created]
  workflow_dispatch:
    inputs:
      target:
        description: 'Deployment target'
        required: true
        type: choice
        options:
          - npm
          - docker
      tag:
        description: 'Version tag'
        required: true
        type: choice
        options:
          - dev
          - beta
          - latest
      dry_run:
        description: 'Dry run (test without publishing)'
        required: false
        type: boolean
        default: false

jobs:
  handle-deploy:
    # Only run when comment contains /deploy command or manual trigger
    if: |
      github.event_name == 'workflow_dispatch' ||
      (github.event.issue && contains(github.event.comment.body, '/deploy'))

    runs-on: ubuntu-latest

    permissions:
      contents: read
      packages: write
      deployments: write
      issues: write
      pull-requests: write
      id-token: write  # For OIDC

    environment:
      name: deploy
      url: ${{ steps.deploy.outputs.url }}

    steps:
      - name: Parse command
        id: parse
        run: |
          # Handle both workflow_dispatch and issue_comment
          if [ "${{ github.event_name }}" = "workflow_dispatch" ]; then
            # Use inputs from manual trigger
            TARGET="${{ github.event.inputs.target }}"
            TAG="${{ github.event.inputs.tag }}"
            DRY_RUN="${{ github.event.inputs.dry_run }}"
            AUTO="false"
            echo "üìã Manual trigger with target=$TARGET, tag=$TAG, dry_run=$DRY_RUN"
          else
            # Parse from comment
            COMMENT="${{ github.event.comment.body }}"
            echo "Raw comment: $COMMENT"

            # Extract command line
            COMMAND=$(echo "$COMMENT" | grep -o '/deploy[^/]*' | head -1 || echo "")
            echo "Extracted command: $COMMAND"

            # Parse target (npm or docker)
            if echo "$COMMAND" | grep -q "npm"; then
              TARGET="npm"
            elif echo "$COMMAND" | grep -q "docker"; then
              TARGET="docker"
            else
              TARGET=""
            fi

            # Parse tag (dev, beta, latest)
            if echo "$COMMAND" | grep -q -- "--tag"; then
              TAG=$(echo "$COMMAND" | sed -n 's/.*--tag[[:space:]]\+\([^[:space:]]*\).*/\1/p')
            else
              TAG="latest"
            fi

            # Parse dry-run
            if echo "$COMMAND" | grep -q -- "--dry-run"; then
              DRY_RUN="true"
            else
              DRY_RUN="false"
            fi

            # Parse auto flag (for automated deployments)
            if echo "$COMMAND" | grep -q -- "--auto"; then
              AUTO="true"
            else
              AUTO="false"
            fi
          fi

          echo "target=$TARGET" >> $GITHUB_OUTPUT
          echo "tag=$TAG" >> $GITHUB_OUTPUT
          echo "dry_run=$DRY_RUN" >> $GITHUB_OUTPUT
          echo "auto=$AUTO" >> $GITHUB_OUTPUT

      - name: Check permissions
        id: permissions
        uses: actions/github-script@v7
        with:
          script: |
            // Skip permission check for manual triggers
            if (context.eventName === 'workflow_dispatch') {
              console.log('Manual trigger - skipping permission check');
              return true;
            }

            const { owner, repo } = context.repo;
            const username = context.payload.comment.user.login;

            // Allow github-actions bot for automated deployments
            if (username === 'github-actions[bot]' || username === 'github-actions') {
              console.log('Allowing github-actions bot');
              return true;
            }

            try {
              const { data: permission } = await github.rest.repos.getCollaboratorPermissionLevel({
                owner,
                repo,
                username
              });

              const allowed = ['admin', 'maintain', 'write'].includes(permission.permission);
              console.log(`User ${username} has ${permission.permission} permission: ${allowed ? 'allowed' : 'denied'}`);

              if (!allowed) {
                await github.rest.issues.createComment({
                  owner,
                  repo,
                  issue_number: context.issue.number,
                  body: `‚ùå @${username} You don't have permission to deploy. Need write access or higher.`
                });
              }

              return allowed;
            } catch (error) {
              console.error('Error checking permissions:', error);
              return false;
            }
          result-encoding: string

      - name: Validate command
        id: validate
        if: steps.permissions.outputs.result == 'true'
        run: |
          TARGET="${{ steps.parse.outputs.target }}"
          TAG="${{ steps.parse.outputs.tag }}"

          # Run validation script
          cat > validate.sh << 'EOF'
          #!/bin/bash
          set -e

          TARGET="$1"
          TAG="$2"

          # Validate target
          if [[ -z "$TARGET" ]]; then
            echo "error=Missing deployment target. Use: /deploy <npm|docker> --tag <dev|beta|latest>" >> $GITHUB_OUTPUT
            echo "valid=false" >> $GITHUB_OUTPUT
            exit 0
          fi

          if [[ "$TARGET" != "npm" && "$TARGET" != "docker" ]]; then
            echo "error=Invalid target: $TARGET. Must be 'npm' or 'docker'" >> $GITHUB_OUTPUT
            echo "valid=false" >> $GITHUB_OUTPUT
            exit 0
          fi

          # Validate tag
          if [[ "$TAG" != "dev" && "$TAG" != "beta" && "$TAG" != "latest" ]]; then
            echo "error=Invalid tag: $TAG. Must be 'dev', 'beta', or 'latest'" >> $GITHUB_OUTPUT
            echo "valid=false" >> $GITHUB_OUTPUT
            exit 0
          fi

          echo "valid=true" >> $GITHUB_OUTPUT
          echo "‚úÖ Command validated: deploy $TARGET with tag $TAG"
          EOF

          chmod +x validate.sh
          ./validate.sh "$TARGET" "$TAG"

      - name: React to comment
        if: steps.permissions.outputs.result == 'true' && steps.validate.outputs.valid == 'true' && github.event_name == 'issue_comment'
        uses: actions/github-script@v7
        with:
          script: |
            await github.rest.reactions.createForIssueComment({
              owner: context.repo.owner,
              repo: context.repo.repo,
              comment_id: context.payload.comment.id,
              content: 'rocket'
            });

      - name: Post validation error
        if: steps.permissions.outputs.result == 'true' && steps.validate.outputs.valid == 'false' && github.event_name == 'issue_comment'
        uses: actions/github-script@v7
        env:
          VALIDATION_ERROR: ${{ steps.validate.outputs.error }}
        with:
          script: |
            const error = process.env.VALIDATION_ERROR;
            await github.rest.issues.createComment({
              owner: context.repo.owner,
              repo: context.repo.repo,
              issue_number: context.issue.number,
              body: `‚ùå **Deploy Failed**\n\n${error}\n\nUsage: \`/deploy <npm|docker> --tag <dev|beta|latest>\``
            });

      - name: Checkout code
        if: steps.permissions.outputs.result == 'true' && steps.validate.outputs.valid == 'true'
        uses: actions/checkout@v4
        with:
          fetch-depth: 0
          # Ê†πÊçÆtagÈÄâÊã©‰∏çÂêåÁöÑÂàÜÊîØ
          # dev -> develop, beta -> release/PR, latest -> main
          ref: ${{ steps.parse.outputs.tag == 'dev' && 'develop' || (steps.parse.outputs.tag == 'latest' && 'main' || (github.event.issue.pull_request && format('refs/pull/{0}/head', github.event.issue.number) || github.ref)) }}

      - name: Create deployment
        if: steps.permissions.outputs.result == 'true' && steps.validate.outputs.valid == 'true'
        id: deployment
        uses: actions/github-script@v7
        with:
          script: |
            const target = '${{ steps.parse.outputs.target }}';
            const tag = '${{ steps.parse.outputs.tag }}';

            // Map tag to environment
            const envMap = {
              'dev': 'development',
              'beta': 'staging',
              'latest': 'production'
            };

            const environment = `${target}-${envMap[tag]}`;

            // Get the ref to deploy
            let ref = context.sha;
            if (context.payload.issue && context.payload.issue.pull_request) {
              const pr = await github.rest.pulls.get({
                owner: context.repo.owner,
                repo: context.repo.repo,
                pull_number: context.issue.number
              });
              ref = pr.data.head.sha;
            }

            // Create deployment
            const deployment = await github.rest.repos.createDeployment({
              owner: context.repo.owner,
              repo: context.repo.repo,
              ref: ref,
              environment: environment,
              description: `Deploy ${target} with tag ${tag}`,
              auto_merge: false,
              required_contexts: [],
              payload: {
                target: target,
                tag: tag,
                triggered_by: context.actor,
                auto: '${{ steps.parse.outputs.auto }}'
              }
            });

            core.setOutput('deployment_id', deployment.data.id);
            core.setOutput('environment', environment);
            console.log(`Created deployment #${deployment.data.id} for ${environment}`);

            // Set initial status
            await github.rest.repos.createDeploymentStatus({
              owner: context.repo.owner,
              repo: context.repo.repo,
              deployment_id: deployment.data.id,
              state: 'in_progress',
              description: `Deploying ${target} to ${envMap[tag]}`
            });
          result-encoding: string

      - name: Detect project type
        if: steps.permissions.outputs.result == 'true' && steps.validate.outputs.valid == 'true'
        id: detect
        run: |
          # Detect project type based on files present
          if [ -f "package.json" ]; then
            echo "type=node" >> $GITHUB_OUTPUT
            echo "üì¶ Detected Node.js project"
          elif [ -f "Dockerfile" ]; then
            echo "type=docker" >> $GITHUB_OUTPUT
            echo "üê≥ Detected Docker project"
          else
            echo "type=unknown" >> $GITHUB_OUTPUT
            echo "‚ùì Could not detect project type"
          fi

      - name: Setup Node.js for NPM
        if: |
          steps.permissions.outputs.result == 'true' &&
          steps.validate.outputs.valid == 'true' &&
          steps.parse.outputs.target == 'npm'
        uses: actions/setup-node@v4
        with:
          node-version: '20'
          registry-url: 'https://registry.npmjs.org'

      - name: Deploy to NPM Registry
        if: |
          steps.permissions.outputs.result == 'true' &&
          steps.validate.outputs.valid == 'true' &&
          steps.parse.outputs.target == 'npm'
        id: deploy-npm
        env:
          NODE_AUTH_TOKEN: ${{ secrets.ORG_NPM_TOKEN }}
          NPM_CONFIG_PROVENANCE: true
        run: |
          TAG="${{ steps.parse.outputs.tag }}"
          DRY_RUN="${{ steps.parse.outputs.dry_run }}"

          echo "üì¶ Deploying to NPM with tag: $TAG"
          echo "üîç Dry run mode: $DRY_RUN"

          # Install dependencies if needed
          if [ -f "pnpm-lock.yaml" ]; then
            npm install -g pnpm
            pnpm install --frozen-lockfile
          elif [ -f "yarn.lock" ]; then
            npm install -g yarn
            yarn install --frozen-lockfile
          elif [ -f "package-lock.json" ]; then
            npm ci
          else
            npm install
          fi

          # Get package name and current version
          PACKAGE_NAME=$(node -p "require('./package.json').name")
          CURRENT_VERSION=$(node -p "require('./package.json').version")

          echo "üì¶ Package: $PACKAGE_NAME"
          echo "üìå Current version: $CURRENT_VERSION"

          # Handle dev tag with auto-increment
          if [ "$TAG" = "dev" ]; then
            echo "üîÑ Checking for existing dev versions..."

            # Get all published versions with dev tag
            EXISTING_VERSIONS=$(npm view "$PACKAGE_NAME" versions --json 2>/dev/null | jq -r '.[]' | grep -E "${CURRENT_VERSION}-dev\." || echo "")

            if [ -z "$EXISTING_VERSIONS" ]; then
              # No dev versions exist, start with dev.1
              DEV_NUMBER=1
            else
              # Find the highest dev number
              HIGHEST_DEV=$(echo "$EXISTING_VERSIONS" | sed -n "s/.*-dev\.\([0-9]*\).*/\1/p" | sort -n | tail -1)
              DEV_NUMBER=$((HIGHEST_DEV + 1))
            fi

            # Update version for dev
            NEW_VERSION="${CURRENT_VERSION}-dev.${DEV_NUMBER}"
            echo "üìà Auto-incremented dev version: $NEW_VERSION"

            # Update package.json with new version
            npm version "$NEW_VERSION" --no-git-tag-version
          fi

          # Build if needed
          if [ -f "tsconfig.json" ] || [ -f "build" ] || grep -q '"build":' package.json; then
            echo "üî® Building package..."
            npm run build || true
          fi

          # Publish or dry run
          if [ "$DRY_RUN" = "true" ]; then
            echo "üß™ Running npm publish in dry-run mode..."
            npm publish --dry-run --tag "$TAG"
          else
            echo "üöÄ Publishing to NPM..."
            npm publish --tag "$TAG" --access public

            # Output the published version
            if [ "$TAG" = "dev" ]; then
              echo "published_version=$NEW_VERSION" >> $GITHUB_OUTPUT
            else
              echo "published_version=$CURRENT_VERSION" >> $GITHUB_OUTPUT
            fi
          fi

          echo "deployed=true" >> $GITHUB_OUTPUT
          echo "npm_deployed=true" >> $GITHUB_OUTPUT

      - name: Setup Node.js for GitHub Packages
        if: |
          steps.permissions.outputs.result == 'true' &&
          steps.validate.outputs.valid == 'true' &&
          steps.parse.outputs.target == 'npm' &&
          steps.deploy-npm.outputs.npm_deployed == 'true' &&
          steps.parse.outputs.dry_run != 'true'
        uses: actions/setup-node@v4
        with:
          node-version: '20'
          registry-url: 'https://npm.pkg.github.com'
          scope: '@promptx'

      - name: Deploy to GitHub Packages
        if: |
          steps.permissions.outputs.result == 'true' &&
          steps.validate.outputs.valid == 'true' &&
          steps.parse.outputs.target == 'npm' &&
          steps.deploy-npm.outputs.npm_deployed == 'true' &&
          steps.parse.outputs.dry_run != 'true'
        id: deploy-github-packages
        env:
          NODE_AUTH_TOKEN: ${{ secrets.GITHUB_TOKEN }}
        run: |
          echo "üì¶ Publishing to GitHub Packages..."
          
          # Get the current package info
          PACKAGE_NAME=$(node -p "require('./package.json').name")
          CURRENT_VERSION=$(node -p "require('./package.json').version")
          TAG="${{ steps.parse.outputs.tag }}"
          
          echo "üìå Publishing $PACKAGE_NAME@$CURRENT_VERSION to GitHub Packages with tag: $TAG"
          
          # Setup npm authentication for GitHub Packages
          echo "//npm.pkg.github.com/:_authToken=$NODE_AUTH_TOKEN" > ~/.npmrc
          echo "@deepractice:registry=https://npm.pkg.github.com" >> ~/.npmrc
          
          # Temporarily update package.json for GitHub Packages
          # GitHub Packages requires the package name to match the GitHub org
          node -e "
          const fs = require('fs');
          const pkg = require('./package.json');
          const originalName = pkg.name;
          
          // GitHub Packages requires @org/package format matching the GitHub org
          if (pkg.name.startsWith('@promptx/')) {
            pkg.name = pkg.name.replace('@promptx/', '@deepractice/promptx-');
            console.log('üìù Adjusted package name for GitHub Packages:', originalName, '->', pkg.name);
          }
          
          pkg.publishConfig = {
            registry: 'https://npm.pkg.github.com',
            access: 'public'
          };
          fs.writeFileSync('./package.json', JSON.stringify(pkg, null, 2));
          "
          
          # Publish to GitHub Packages with proper auth
          npm publish --tag "$TAG" --registry https://npm.pkg.github.com --access public || {
            echo "‚ö†Ô∏è Failed to publish to GitHub Packages (may already exist or permission issue)"
            echo "üìã This is expected if the version already exists"
          }
          
          # Restore original package.json
          git checkout -- package.json
          
          echo "github_packages_deployed=true" >> $GITHUB_OUTPUT

      - name: Setup Docker Buildx
        if: |
          steps.permissions.outputs.result == 'true' &&
          steps.validate.outputs.valid == 'true' &&
          steps.parse.outputs.target == 'docker'
        uses: docker/setup-buildx-action@v3

      # Docker Hub login skipped - no credentials configured
      
      - name: Login to GitHub Container Registry
        if: |
          steps.permissions.outputs.result == 'true' &&
          steps.validate.outputs.valid == 'true' &&
          steps.parse.outputs.target == 'docker' &&
          steps.parse.outputs.dry_run != 'true'
        uses: docker/login-action@v3
        with:
          registry: ghcr.io
          username: ${{ github.actor }}
          password: ${{ secrets.GITHUB_TOKEN }}

      - name: Deploy to Docker
        if: |
          steps.permissions.outputs.result == 'true' &&
          steps.validate.outputs.valid == 'true' &&
          steps.parse.outputs.target == 'docker'
        id: deploy-docker
        env:
          DOCKER_TOKEN: ${{ secrets.DOCKER_TOKEN || secrets.GITHUB_TOKEN }}
        run: |
          # Copy docker deploy script
          cp commands/deploy/scripts/docker.sh ./
          chmod +x docker.sh

          TAG="${{ steps.parse.outputs.tag }}"
          DRY_RUN="${{ steps.parse.outputs.dry_run }}"

          # Determine registry
          REGISTRY="ghcr.io"

          ./docker.sh --tag "$TAG" --registry "$REGISTRY" --dry-run "$DRY_RUN"

          echo "deployed=true" >> $GITHUB_OUTPUT

      - name: Update deployment status (success)
        if: |
          steps.permissions.outputs.result == 'true' &&
          steps.validate.outputs.valid == 'true' &&
          (steps.deploy-npm.outputs.deployed == 'true' || steps.deploy-docker.outputs.deployed == 'true')
        uses: actions/github-script@v7
        with:
          script: |
            const target = '${{ steps.parse.outputs.target }}';
            const tag = '${{ steps.parse.outputs.tag }}';
            const dryRun = '${{ steps.parse.outputs.dry_run }}' === 'true';

            let url = '';
            let description = '';

            if (target === 'npm') {
              const packageName = require('./package.json').name;
              const githubPackagesDeployed = '${{ steps.deploy-github-packages.outputs.github_packages_deployed }}' === 'true';
              url = `https://www.npmjs.com/package/${packageName}`;
              
              if (dryRun) {
                description = `Dry run completed for ${packageName}`;
              } else if (githubPackagesDeployed) {
                description = `Deployed ${packageName} to NPM and GitHub Packages with tag ${tag}`;
              } else {
                description = `Deployed ${packageName} to NPM with tag ${tag}`;
              }
            } else if (target === 'docker') {
              const registry = 'ghcr.io';
              const imageName = `ghcr.io/${{ github.repository }}`;
              url = `https://github.com/${{ github.repository }}/pkgs/container/${imageName.split('/').pop()}`;
              description = dryRun ?
                `Dry run completed for ${imageName}` :
                `Deployed ${imageName}:${tag}`;
            }

            await github.rest.repos.createDeploymentStatus({
              owner: context.repo.owner,
              repo: context.repo.repo,
              deployment_id: ${{ steps.deployment.outputs.deployment_id }},
              state: dryRun ? 'inactive' : 'success',
              environment_url: url,
              description: description
            });

            // Post success comment
            const isAuto = '${{ steps.parse.outputs.auto }}' === 'true';
            if (!isAuto && context.eventName === 'issue_comment') {
              let message = dryRun ?
                `‚úÖ **Deploy Preview Successful**\n\n${description}` :
                `üöÄ **Deploy Successful**\n\n${description}`;

              if (url) {
                message += `\n\nüîó [View Deployment](${url})`;
              }

              await github.rest.issues.createComment({
                owner: context.repo.owner,
                repo: context.repo.repo,
                issue_number: context.issue.number,
                body: message
              });
            }

      - name: Update deployment status (failure)
        if: failure() && steps.permissions.outputs.result == 'true' && steps.validate.outputs.valid == 'true'
        uses: actions/github-script@v7
        with:
          script: |
            if ('${{ steps.deployment.outputs.deployment_id }}') {
              await github.rest.repos.createDeploymentStatus({
                owner: context.repo.owner,
                repo: context.repo.repo,
                deployment_id: '${{ steps.deployment.outputs.deployment_id }}',
                state: 'failure',
                description: 'Deployment failed'
              });
            }

            const isAuto = '${{ steps.parse.outputs.auto }}' === 'true';
            if (!isAuto && context.eventName === 'issue_comment') {
              await github.rest.issues.createComment({
                owner: context.repo.owner,
                repo: context.repo.repo,
                issue_number: context.issue.number,
                body: `‚ùå **Deploy Failed**\n\nCheck the [workflow logs](${{ github.server_url }}/${{ github.repository }}/actions/runs/${{ github.run_id }}) for details.`
              });
            }